---
title: Comparison Report
output: pdf_document
---
<!-- 
    This file is used to make it easier to resolve issues of accidentally collecting too few or too much data with the Sonde
-->

<!-- This chunk handles a bunch of pre-processing and won't display anything -->
```{r include=FALSE}
# Load libraries being used
library(readxl)
library(ggplot2)
library(tibble)
library(dplyr)

# Adds a list of global variables into the current environment from 00_Globals.r
# This portion of the code assumes that you are in the root of the repository
# However, when knitr is used, it'll likely start a new R process who's working directory is the folder of current file
# - Root <- This is the root of the repository
#   - 01_Data
#     - MHK_Data
#       - ...
#   - 02_Scripts
#     - ...
#   - 03_Graphs
#     - ...
#   - 04_Rmarkdown <- Working directory of knitr process
#     - ...
#   - ...

if (basename(getwd()) == "04_Rmarkdown"){
  source(file.path("..", "02_Scripts", "00_Globals.r"))
} else {
  source(file.path("02_Scripts", "00_Globals.r"))
}

# Name of the file with errors
error_file_name <- "MHK_2024_11_25_profile[TOO LITTLE].csv"

# Constructs an OS agnostic path to the file
error_file_path <- file.path(KOR_FORMATTED_DATA_DIR, error_file_name)

# Ensure the file actually exists, else stop the execution of the program
if (!file.exists(error_file_path)) {
  stop(paste("The path '", error_file_path, "'' leads to nothing"))
}

# The file with the errors in it is loaded as a dataframe
error_df <- readr::read_csv(error_file_path)

# Checks to see if the file has 2024 or 2025 in its name and
# Then, chooses the correct DO sensor file to compare to
# NOTE: Any comments on the data are stored in the original files they came from (Minnewaska_FieldDataYYYY.xlsx)
if (grepl("2024", error_file_name)) {
  do_sensor_df <- readxl::read_excel(file.path(DO_SENSOR_DATA_DIR, "MHK_2024_DOSensor.xlsx"))
} else if (grepl("2025", error_file_name)) {
  do_sensor_df <- readxl::read_excel(file.path(DO_SENSOR_DATA_DIR, "MHK_2025_DOSensor.xlsx"))
}
```

<!-- Begin the stuff that should be edited by the user -->
<!-- Every line with 5 #'s should be edited if desired -->

```{r include=FALSE}
# The expected amount of rows is 49 because we go from 0 to 12 meters and count every 0.25 meters
# This value should not change which is why it's in caps
EXPECTED_ROW_COUNT <- 49

# Stores the amount of rows in the error dataframe
error_df_row_count <- nrow(error_df)

# The amount of extra or missing rows
extra_or_missing_rows_count <- EXPECTED_ROW_COUNT - error_df_row_count

is_extra <- extra_or_missing_rows_count < 0
is_missing <- extra_or_missing_rows_count > 0

# If we get a negative number,
# then the count should still be positive as it'll be a count for how many extra rows are there
extra_or_missing_rows_count <- abs(extra_or_missing_rows_count)

# These are the rows that are either removed or added to the error df
# When empty, rows are chosen randomly
rows_to_modify <- c() #####

# Choose rows randomly if empty
if (length(rows_to_modify) == 0) {
  # Choose n extra rows randomly
  rows_to_modify <- sample(1:nrow(error_df), extra_or_missing_rows_count)
}
```

<!-- Show the rows being modified -->

```{r}
paste0("The rows being modified are: ", paste(rows_to_modify, collapse = ", "))
```

<!-- Remove or Add the rows -->

```{r include=FALSE}
if (is_missing) {
  # If missing, add rows of NA at specified positions
  for (i in rows_to_modify) {
    # Added tibble:: to tell the interpreter that we're using the tibble library and not the dplyr library
    error_df <- tibble::add_row(error_df, .before = i)
  }
} else if (is_extra) {
  # If extra, delete rows from the rows_to_modify vector
  error_df <- error_df[-rows_to_modify, ]
}
```

